TODO:
Processor:
	Replace coregen block ram main_memory in memory_controller with exmem style verilog memory.
	Jake
		- Having to regenerate the core to load program is annoying.
	Replace coregen block ram main_memory in memory_controller with exmem style verilog memory.
		- Having to regenerate the core to load program is annoying.

Application:
	Boot code - set initial $fp, $sp
	Macros for memory locations in memory map
	
Gpu:
	Create a glyph-style background module. 
	Matt
		- The pixel from the background will be combined with the current output of the gpu.
		- Use last 1kw block ram for a background glyph table (leaves 8 kw for program)
		- this is 64x64 pixels at 16 colors. Could organize as
			- 64 8x8 tiles, 6 address bits per segment, and 80x60 segments. (4800x6bits) - way too big
			- 16 16x16 tiles, 4 address bits per segment, and 40x30 segments. (1200x4bits) - reasonable
			- 4 32x32 tile, 2 address bits per segment, and 20x15 segments. (300x2bits)
			- glyph does not have to be square
			- No more block rams, make a distributed ram for table.
		- Could use fewer colors, fewer palette selections, get a larger table,
			- 64x128 at 4 colors
			- 8 32x32, 3 address bits per segment, (300x3xp bits)
			
	Zoom mode - 320x240
		- modify vga to increment x and y at half speed.
		
Controllers:
	Jake
	3.3v compatibility
		- SNES provides 5 volts, will it work with 3.3?
	Add to memory map (add to memory_controller and system)
	Logic for shifting/storage
		- Once per VBLANK?
	Some sort of connector
		- Cannibalize (Thrift store hunting)
		- Simple solution is a bunch of ~14 gauge wire.
		- Maybe drill some holes in plexiglass to keep pins aligned.
	Zapper protocol
		- Two output wires, one for trigger, one for light sensor
	
Assembler:
	*parameterized macros
	
Sound:
	Billy
	
Processor:
	*Implement wait operation
		- wait $rx, $ry
		- 16-bit processor interrupt register, flags for things like VBLANK
		- ry is a mask for the PIR, and the processor waits until ry&PIR is non-zero
		- as processor starts up again, ry&PIR is written to $rx
	*Any other operations
		- modulo
		- tbit, tbiti
	*Counter
		- 32-bit, incr every clock (86 sec period)
